# Data Structure Experiment
华中科技大学网安学院大一下必修课《数据结构实验》

## 理论课编程作业1-1：链表节点的删除和添加操作

### 任务描述
本关任务：补充完整删除和添加节点的子函数

### 相关知识
为了完成本关任务，你需要掌握：
1. 如何对链表添加节点；
2. 如何查找信息在链表的位置；
3. 如何删除对应节点。

### 编程要求
根据提示，在右侧编辑器补充代码，程序会自己调用你所填写的函数。

函数`insertTail`：链表尾部插入；

    参数：`h`-链表头指针，`t`-指向要插入的结点；
    
    返回值：插入结点后链表的首结点地址。
    
函数`delNode`:删除指定数值；

    参数：h-链表表头指针，e指定节点的数值；
    
    如果该数值的节点存在，就删除节点，否则打印“error”。
    
提示：

在开始做题前建议查看完整代码

<img width="226" height="46" alt="image" src="https://github.com/user-attachments/assets/1d2aa263-0ba8-4a3b-b832-962e360154f0" />

### 数据结构

```
typedef struct node
{
    int data;  // 数据域
    struct node * next;  //指针域,指向下一个结点
}node;
```

### 输入标准

第一行输入一个数n，表示要存入数据的个数

第二行输入n个数，表示要存入的数据（各不相同）

第三行输入要删除的元素

### 输出标准

如果需要删除的元素不存在输出"error\n";

删除成功不需要输出。

### 测试说明

平台会对你编写的代码进行测试：

测试输入：
```
5
1 2 3 4 5
3
```
预期输出：

```List :1 2 4 5```

测试输入：
```
3
1 4 5
2
```
预期输出：
```
error
List:1 4 5
```

另有一组隐藏测试数据。

**开始你的任务吧，祝你成功！**


## 理论课编程作业1-2：链栈的应用——括号匹配

### 任务描述
本关任务：设计一个算法，判断一个可能含有花括号、中括号、和圆括号的表达式中各类括号是否匹配，若匹配，则返回1；否则返回0。其中表达式只包含三种括号，花括号{}、中括号[]、圆括号()，即它仅由 (、)、[、]、{、}六个字符组成。

### 相关知识
将链栈的类型定义及基本操作函数的声明放在头文件slink.h中，将链栈的基本操作函数的定义放在源文件slink.cpp中，那么可以借助链栈实现判断表达式括号是否匹配任务。

从左至右扫描一个表达式(或字符串)，则每个右括号将与最近遇到的那个左括号相匹配。

在从左至右扫描表达式过程中把所遇到的左括号存放到栈中。

每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。

### 算法思想
设置一个栈，当读到左括号时，左括号进栈。当读到右括号时，则从栈中弹出一个元素，与读到的左括号进行匹配，若匹配成功，继续读入；否则匹配失败。另外，在算法的开始和结束时，栈都应该是空的，所以匹配到最后还要判断栈是否为空，若空，则说明匹配成功，返回1。若非空，则说明匹配失败，返回0。

步骤如下：

设置一个链栈st，定义一个整型flag变量（初始为1）。

用i扫描表达式exp，当i<n并且flag=1时循环：

当遇到左括号“(”、“[”、“{”时，将其进栈；

遇到“}”、“]”、“)”时，出栈字符ch，若出栈失败（下溢出）或者ch不匹配，则置flag=0退出循环;

否则直到exp扫描完毕为止。

若栈空并且flag为1则返回1，否则返回0。

### 编程要求
根据提示，在右侧编辑器 Begin - End 之间补充代码，判断表达式（或字符串）中括号是否成对出现。

### 数据结构
```
typedef struct{
    char data[30]; 
    int top; 
}sqstack;
```

### 测试说明
平台会对你编写的代码进行测试，只有所有数据全部计算正确才能通过测试：

测试输入：`{ [ ] ( ) }`

预期输出：`匹配成功`

测试输入：`[ ( { } ] [ ) ]`

预期输出：`匹配失败`

**开始你的任务吧，祝你成功！**

## 理论课编程作业1-3：二叉树深度

### 任务描述
根据带有空二叉树的先序序列建树

建好这棵二叉树之后，请求出它的深度。二叉树的深度是指从根节点到叶子结点时，最多经过了几层。如果是空树，深度为零。

### 数据结构
```
typedef struct Bitnode
{
    char data;
    struct Bitnode *left,*right;
}Bitnode;
```

### 输入格式
第一行一个字符串，字符表示节点的名字，‘#’表示是空节点，‘$’表示结束。

### 输出格式
一个整数，表示最大结点深度。

### 样例 #1

**样例输入 #1**

`ABC#D###E##$`

**样例输出 #1**

`4`

**开始你的任务吧，祝你成功！**

## 数据结构实验一 Huffman编解码 第1关：统计字符频度

### 任务描述
本关任务：建立频度链表来统计字符的频度。

### 相关知识
为了完成本关任务，你需要掌握：
1. 建立单链表
2. 单链表排序

**建立单链表**

1. 频度链表数据结构：
```
struct ListNode            //结点结构，哈夫曼树与频度链表共用
{
    char      c;                    //结点的字符
    int      frequency;            // 字符的频度
    char     *code;            // 字符的编码(对哈夫曼树结点有效)
    struct ListNode *parent;            //结点的双亲结点(对哈夫曼树结点有效)
    struct ListNode *left;                //结点的左子树(对哈夫曼树结点有效)
    struct ListNode *right;                // 结点的右子树(对哈夫曼树结点有效)
    struct ListNode *next;                // 结点的后继结点(对频度链表结点有效)
}
```
2. 若字符在频度链表中存在，则该字符的频度加1，否则创建新结点并将该结点插入到频度链表中。

**单链表排序**

对所得到的频度链表进行排序，使得字符的频度按从高到低排列。

### 编程要求
根据提示，在右侧编辑器补充代码，建立频度链表并排序，从高到低输出各个字符的频度。

### 测试说明
平台会对你编写的代码进行测试：

测试输入：

`hello world!`

预期输出：
```
'l' 3
'o' 2
'h' 1
'e' 1
' ' 1
'w' 1
'r' 1
'd' 1
'!' 1
```

测试输入：
```
Data structure experiment
HuffmanTree
metro line
```

预期输出：
```
'e' 8
't' 5
'r' 5
'a' 3
' ' 3
'u' 3
'm' 3
'n' 3
'i' 2
'\n' 2
'f' 2
'D' 1
's' 1
'c' 1
'x' 1
'p' 1
'H' 1
'T' 1
'o' 1
'l' 1
```

**提示：**

1. 字符按频度从高到低排列，相同频度的字符按输入先后进行排列，先输入的字符排列在前，后输入的字符排列在后。
2. 输出示例为'字符' 频度，字符和频度之间有一个空格，输出完一个字符和频度后换行再输出下一个字符和频度。
3. 换行符字符输出示例`'\n' 10`。
4. 最后一个字符和频度输出完后仍有一个换行符要输出。

**开始你的任务吧，祝你成功！**


## 数据结构实验一 Huffman编解码 第2关：建立哈夫曼树并生成哈夫曼编码

### 任务描述
本关任务：编写一个程序，利用上一关的频度链表，建立相应的哈夫曼树，并得到相应的哈夫曼编码。

### 相关知识
为了完成本关任务，你需要掌握：
1. 建立二叉树
2. 遍历二叉树

### 编程要求
采用原址建立的方法，利用上一关得到的频度链表，将频度链表中的结点作为哈夫曼树中的结点，建立哈夫曼树。算法循环执行的每一次循环中，从还没有指定双亲指针的结点中选择频度最小的元素和频度次小的两结点。创建其二者的双亲结点并设置二者的双亲指针指向该结点，同时使双亲结点的左右孩指针指向两结点。之后将生成的双亲结点插入到频度链表中。循环执行至除根结点外的所有结点都具有双亲指针为止，哈夫曼树建立成功。

先序遍历哈夫曼树，得到各个叶子结点的哈夫曼编码，并按上一关中的顺序输出相应的哈夫曼编码。

并在最后一行输出哈夫曼树的带权路径长度，权重为字符的频度。

根据提示，在右侧编辑器补充相应代码。

### 测试说明
平台会对你编写的代码进行测试：

测试输入：
```
Data structure experiment
HuffmanTree
metro line
```

预期输出：
```
'e' 8 110
't' 5 001
'r' 5 010
'a' 3 0110
' ' 3 0111
'u' 3 1000
'm' 3 1001
'n' 3 1010
'i' 2 10111
'\n' 2 11100
'f' 2 11101
'D' 1 111100
's' 1 111101
'c' 1 111110
'x' 1 111111
'p' 1 00000
'H' 1 00001
'T' 1 00010
'o' 1 00011
'l' 1 10110
193
```

**提示：**

1. 由于同一文本建立的哈夫曼树不同，则得到的哈夫曼编码不唯一。上述样例给出的哈夫曼编码只是其中一种答案。
2. 带权路径长度输出后不用再输出换行符。

**开始你的任务吧，祝你成功！**

## 数据结构实验一 Huffman编解码 第3关：哈夫曼编码和解码

### 任务描述
本关任务：编写编码程序和解码程序，利用上一关得到的哈夫曼编码对所给文本进行编码和解码。

### 相关知识
为了完成本关任务，你需要掌握：
1. 查找二叉树的结点
2. 判断叶子结点

### 编程要求
根据提示，在右侧编辑器补充代码，对所给文本进行编码和解码，并输出编码后的文本，解码后的文本以及编码后文本的长度。

### 测试说明
平台会对你编写的代码进行测试：

测试输入：
```
Data structure experiment
HuffmanTree
metro line
```

预期输出：
```
1111000110001011001111111010010101000111110001100001011001111101111110000011001010111100111010100011110000001100011101111011001011010100001001011011011100100111000101000011011110110101111010110
Data structure experiment
HuffmanTree
metro line
193
```

**提示：**

1. 由于同一文本建立的哈夫曼树不同且得到的哈夫曼编码不唯一。上述样例给出的编码文本只是其中一种答案。
2. 换行符也要转换成相应的哈夫曼编码。
3. 输出编码后的文本长度后不需要再输出换行符。

**开始你的任务吧，祝你成功！**

## 数据结构实验二 图 第1关：地铁线路图的建立与寻找换乘站点

### 任务描述
本关任务：使用邻接表构成图来表达地铁线路，存储武汉地铁若干站点在相邻站点的线路信息，线路信息仅包含两相邻站点名称与其相距的距离。其中地铁线路均为双向线路，不同线路中相同站名的地铁站为转乘车站

### 相关知识
为了完成本关任务，你需要掌握：
1. 如何选取合适的数据结构存储邻接表
2. 如何使用邻接表构造有向图

**使用邻接表构造图**

图的邻接表由两个部分组成：表头结点和边结点，因此创建有向图也分成两部分：一是创建表头结点，二是创建边结点构成的边表。

### 编程要求
根据提示，在右侧编辑器补充代码，根据给出的信息建立图

并输出所有的中转站点以及与其连接的站点个数

输入形式：在本关中用END！结束输入

站点名1 站点名2 两站相隔的距离

站点名3 站点名1 两站相隔的距离

站点名1 站点名5 两站相隔的距离 **注意：此处的站点1即为换乘站**

…………

END！

输出形式：

换乘站名称1  与换乘站1相邻的站点的个数k1

换乘站名称2  与换乘站2相邻的站点的个数k2

……

换乘站名称n  与换乘站n相邻的站点的个数kn

其中换乘站点的输出顺序与在输入信息出现的先后一致

例如：在测试输入中换乘站点有积玉桥，光谷广场，宝通寺，江汉路四个站点。因在输入的站点信息中出现的先后次序是积玉桥，江汉路，光谷广场，宝通寺。故而输出的次序是积玉桥，江汉路，光谷广场，宝通寺。

### 测试说明
平台会对你编写的代码进行测试：

样例输入：
```
循礼门 积玉桥 1.3
中山公园 积玉桥 0.9
积玉桥 江汉路 3.6
光谷广场 积玉桥 1.6
光谷广场 华中科技大学 2.4
宝通寺 积玉桥 4.4
大智路 宝通寺 1.1
街道口 宝通寺 0.8
昙华林 江汉路 1.8
中南路 江汉路 5.2
江汉路 光谷广场 2.7
光谷广场 珞雄路 3.1
宝通寺 光谷广场 3.6
END!
```

预期输出：
```
积玉桥 5
江汉路 4
光谷广场 5
宝通寺 4
```

**提示：**

构造邻接表
```
typedef struct arc //作为邻接表头节点所指向的边
{   
    char name1[20];          //存储指向的节点
    float dist;         
    struct arc *next;    
} arc;
typedef struct Head //作为邻接表头节点
{  
    char name[20]; //存储站点名称          
    arc * add;        
} Head;
```

**开始你的任务吧，祝你成功！**



