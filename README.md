# Data Structure Experiment
华中科技大学网安学院大一下必修课《数据结构实验》

## 理论课编程作业1-1：链表节点的删除和添加操作

### 任务描述
本关任务：补充完整删除和添加节点的子函数

### 相关知识
为了完成本关任务，你需要掌握：
1. 如何对链表添加节点；
2. 如何查找信息在链表的位置；
3. 如何删除对应节点。

### 编程要求
根据提示，在右侧编辑器补充代码，程序会自己调用你所填写的函数。

函数`insertTail`：链表尾部插入；

    参数：`h`-链表头指针，`t`-指向要插入的结点；
    
    返回值：插入结点后链表的首结点地址。
    
函数`delNode`:删除指定数值；

    参数：h-链表表头指针，e指定节点的数值；
    
    如果该数值的节点存在，就删除节点，否则打印“error”。
    
提示：

在开始做题前建议查看完整代码

<img width="226" height="46" alt="image" src="https://github.com/user-attachments/assets/1d2aa263-0ba8-4a3b-b832-962e360154f0" />

### 数据结构

```
typedef struct node
{
    int data;  // 数据域
    struct node * next;  //指针域,指向下一个结点
}node;
```

### 输入标准

第一行输入一个数n，表示要存入数据的个数

第二行输入n个数，表示要存入的数据（各不相同）

第三行输入要删除的元素

### 输出标准

如果需要删除的元素不存在输出"error\n";

删除成功不需要输出。

### 测试说明

平台会对你编写的代码进行测试：

测试输入：
```
5
1 2 3 4 5
3
```
预期输出：

```List :1 2 4 5```

测试输入：
```
3
1 4 5
2
```
预期输出：
```
error
List:1 4 5
```

另有一组隐藏测试数据。

**开始你的任务吧，祝你成功！**


## 理论课编程作业1-2：链栈的应用——括号匹配

### 任务描述
本关任务：设计一个算法，判断一个可能含有花括号、中括号、和圆括号的表达式中各类括号是否匹配，若匹配，则返回1；否则返回0。其中表达式只包含三种括号，花括号{}、中括号[]、圆括号()，即它仅由 (、)、[、]、{、}六个字符组成。

### 相关知识
将链栈的类型定义及基本操作函数的声明放在头文件slink.h中，将链栈的基本操作函数的定义放在源文件slink.cpp中，那么可以借助链栈实现判断表达式括号是否匹配任务。

从左至右扫描一个表达式(或字符串)，则每个右括号将与最近遇到的那个左括号相匹配。

在从左至右扫描表达式过程中把所遇到的左括号存放到栈中。

每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。

### 算法思想
设置一个栈，当读到左括号时，左括号进栈。当读到右括号时，则从栈中弹出一个元素，与读到的左括号进行匹配，若匹配成功，继续读入；否则匹配失败。另外，在算法的开始和结束时，栈都应该是空的，所以匹配到最后还要判断栈是否为空，若空，则说明匹配成功，返回1。若非空，则说明匹配失败，返回0。

步骤如下：

设置一个链栈st，定义一个整型flag变量（初始为1）。

用i扫描表达式exp，当i<n并且flag=1时循环：

当遇到左括号“(”、“[”、“{”时，将其进栈；

遇到“}”、“]”、“)”时，出栈字符ch，若出栈失败（下溢出）或者ch不匹配，则置flag=0退出循环;

否则直到exp扫描完毕为止。

若栈空并且flag为1则返回1，否则返回0。

### 编程要求
根据提示，在右侧编辑器 Begin - End 之间补充代码，判断表达式（或字符串）中括号是否成对出现。

### 数据结构
```
typedef struct{
    char data[30]; 
    int top; 
}sqstack;
```

### 测试说明
平台会对你编写的代码进行测试，只有所有数据全部计算正确才能通过测试：

测试输入：`{ [ ] ( ) }`

预期输出：`匹配成功`

测试输入：`[ ( { } ] [ ) ]`

预期输出：`匹配失败`

**开始你的任务吧，祝你成功！**

## 理论课编程作业1-3：二叉树深度

### 任务描述
根据带有空二叉树的先序序列建树

建好这棵二叉树之后，请求出它的深度。二叉树的深度是指从根节点到叶子结点时，最多经过了几层。如果是空树，深度为零。

### 数据结构
```
typedef struct Bitnode
{
    char data;
    struct Bitnode *left,*right;
}Bitnode;
```

### 输入格式
第一行一个字符串，字符表示节点的名字，‘#’表示是空节点，‘$’表示结束。

### 输出格式
一个整数，表示最大结点深度。

### 样例 #1

**样例输入 #1**

`ABC#D###E##$`

**样例输出 #1**

`4`

**开始你的任务吧，祝你成功！**


## 数据结构实验一 Huffman编解码 第1关：统计字符频度

### 任务描述
本关任务：建立频度链表来统计字符的频度。

### 相关知识
为了完成本关任务，你需要掌握：
1. 建立单链表
2. 单链表排序

**建立单链表**

1. 频度链表数据结构：
```
struct ListNode            //结点结构，哈夫曼树与频度链表共用
{
    char      c;                    //结点的字符
    int      frequency;            // 字符的频度
    char     *code;            // 字符的编码(对哈夫曼树结点有效)
    struct ListNode *parent;            //结点的双亲结点(对哈夫曼树结点有效)
    struct ListNode *left;                //结点的左子树(对哈夫曼树结点有效)
    struct ListNode *right;                // 结点的右子树(对哈夫曼树结点有效)
    struct ListNode *next;                // 结点的后继结点(对频度链表结点有效)
}
```
2. 若字符在频度链表中存在，则该字符的频度加1，否则创建新结点并将该结点插入到频度链表中。

**单链表排序**

对所得到的频度链表进行排序，使得字符的频度按从高到低排列。

### 编程要求
根据提示，在右侧编辑器补充代码，建立频度链表并排序，从高到低输出各个字符的频度。

### 测试说明
平台会对你编写的代码进行测试：

测试输入：

`hello world!`

预期输出：
```
'l' 3
'o' 2
'h' 1
'e' 1
' ' 1
'w' 1
'r' 1
'd' 1
'!' 1
```

测试输入：
```
Data structure experiment
HuffmanTree
metro line
```

预期输出：
```
'e' 8
't' 5
'r' 5
'a' 3
' ' 3
'u' 3
'm' 3
'n' 3
'i' 2
'\n' 2
'f' 2
'D' 1
's' 1
'c' 1
'x' 1
'p' 1
'H' 1
'T' 1
'o' 1
'l' 1
```

**提示：**

1. 字符按频度从高到低排列，相同频度的字符按输入先后进行排列，先输入的字符排列在前，后输入的字符排列在后
2. 输出示例为'字符' 频度，字符和频度之间有一个空格，输出完一个字符和频度后换行再输出下一个字符和频度
3. 换行符字符输出示例'\n' 10
4. 最后一个字符和频度输出完后仍有一个换行符要输出

**开始你的任务吧，祝你成功！**



